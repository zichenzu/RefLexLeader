#include <gecode/int/branch.hh>#include <gecode/int.hh>namespace Gecode{  	void swap(int& a, int& b){		int temp = a;    		a=b;		b=temp; 	}	int partition(IntArgs& num, int top, int bottom)	{		int i;        i = top-1;		         for(int j=top;j<bottom;j++)        {			if(num[2*j]<num[2*bottom] || (num[2*j]==num[2*bottom] && num[2*j+1]<num[2*bottom+1]))			{				i++;				swap(num[2*i],num[2*j]);				swap(num[2*i+1],num[2*j+1]);    			}        }        i++; 		 		{			swap(num[2*i],num[2*bottom]);			swap(num[2*i+1],num[2*bottom+1]);		}        return i;	 	}	void quicksort(IntArgs& num,int top,int bottom)	{        if(top<bottom)        {                int q;                q = partition(num,top,bottom);                quicksort(num,top,q-1);                quicksort(num,q+1,bottom);        }	}	void bubblesort(IntArgs& num,int size)	{			for(int i=size;i>0;)		{ 			int newn = 0;			for(int j=1;j<i;j++)			{				 				if(num[2*(j-1)]>num[2*j])				{										swap(num[2*(j-1)],num[2*j]);					swap(num[2*(j-1)+1],num[2*j+1]);    					newn = j;				}			}			i = newn;			 		} 	}template<class View> class RefLex : public Propagator { protected: 	ViewArray<View> x, y;	int posx;	int posy;	   public:    	// posting	RefLex(Space& home, ViewArray<View>&  _x, ViewArray<View>& _y) : Propagator(home), x(_x),y(_y),posx(-1),posy(-1) {		 		x.subscribe(home,*this,Int::PC_INT_BND);		y.subscribe(home,*this,Int::PC_INT_BND);	} 	static ExecStatus post(Space& home, ViewArray<View>& x, ViewArray<View>& y) {		(void) new (home) RefLex(home,x, y); 		return ES_OK; 	} 	// disposal 	virtual size_t dispose(Space& home) {		x.cancel(home,*this,Int::PC_INT_BND); 		y.cancel(home,*this,Int::PC_INT_BND); 		(void) Propagator::dispose(home);		return sizeof(*this); 	} 	// copying	RefLex(Space& home, bool share, RefLex& p) : Propagator(home,share,p),posx(p.posx),posy(p.posy) {		 		x.update(home,share,p.x); 		y.update(home,share,p.y); 			} 	virtual Propagator* copy(Space& home, bool share) {		return new (home) RefLex(home,share,*this); 	} 	// cost computation 	virtual PropCost cost(const Space&, const ModEventDelta&) const {		return PropCost::binary(PropCost::LO); 	} 	// propagation 	virtual ExecStatus propagate(Space& home, const ModEventDelta&) {		 		int k=0;		for(int i=0;i<x.size();i++)		{			if(!(x[i].assigned() && y[i].assigned() && x[i].val()==y[i].val()))			{								x[k]=x[i];				y[k++]=y[i];			}			else			{				x[i].cancel(home,*this,Int::PC_INT_BND);				y[i].cancel(home,*this,Int::PC_INT_BND);			}		}						x.drop_lst((k-1));		y.drop_lst((k-1));				 		 		if(x.size()==0) return home.ES_SUBSUMED(*this);		 		 				//get the minimum vector of x		IntArgs ma(x.size()*2);		 		for(int i=0;i<x.size();i++)		{			ma[2*i]=x[i].min();			ma[2*i+1]=i;			 		} 	    		//sort 		//quicksort(ma, 0, x.size()-1);		bubblesort(ma, x.size());		 		//get the maximum vector of y		IntArgs mb(y.size()*2); 		 		for(int i=0;i<y.size();i++)		{			mb[2*i]=y[i].max();			mb[2*i+1]=i;			 		} 	  		//sort 		//quicksort(mb, 0, y.size()-1);		bubblesort(mb, y.size()); 		 		//find the pointer a and b		int a=-1;		int b=-1;		int c=-1; 		int d=-1;		for(int i=0,j=0;i<x.size()&&j<y.size();i++,j++)		{			if((ma[2*i]<mb[2*j] || (ma[2*i]==mb[2*j] && ma[2*i+1]<mb[2*j+1])))				if(a==-1)				{					a=i; 					j--;					continue;				}				else  				{					 					if(b==-1) b=-2; 					break;				}				 			 			else if(ma[2*i]>mb[2*j] || (ma[2*i]==mb[2*j] && ma[2*i+1]>mb[2*j+1]))			{				if(a==-1) {					posx=-2; 					posy=-2; 					//std::cout<<ma[2*i]<<","<<ma[2*i+1]<<"\t"<<mb[2*i]<<","<<mb[2*i+1]<<"\n";					return ES_FAILED;//the optimistic one cannot be satsified				}				if(b==-1)				{					i--;					b=j;				}				else				{					c=i;					break;				}			}			//prune values in x and y			else if(a==-1){				GECODE_ME_CHECK(x[ma[2*i+1]].eq(home,ma[2*i]));				GECODE_ME_CHECK(y[mb[2*j+1]].eq(home,mb[2*j]));			}					} 				if(a==-1 && b==-1) {posx=-2; posy=-2; return home.ES_SUBSUMED(*this);}		 		//prune values in y		 		for(int i=a;i<x.size();i++)			if(!y[mb[2*i+1]].assigned())			{				 				GECODE_ME_CHECK(y[mb[2*i+1]].gq(home,ma[2*a]));			}			 		for(int i=0;i<ma[2*a+1];i++)			if(!y[i].assigned())			{				 				GECODE_ME_CHECK(y[i].gq(home,ma[2*a]+1));			}			 		 		if(!y[ma[2*a+1]].assigned())		{	if(b<0)			{				 				GECODE_ME_CHECK(y[ma[2*a+1]].gq(home,ma[2*a]));			}			else  			{				 				if(mb[2*b+1]==ma[2*a+1])					if(c==-1)						GECODE_ME_CHECK(y[ma[2*a+1]].gq(home,ma[2*a]));					else						GECODE_ME_CHECK(y[ma[2*a+1]].gq(home,ma[2*a]+1)); 				else if(y[ma[2*a+1]].max()<mb[2*b] || y[ma[2*a+1]].max()==mb[2*b] && ma[2*a+1]<mb[2*b+1])						GECODE_ME_CHECK(y[ma[2*a+1]].gq(home,ma[2*a]));					else 						GECODE_ME_CHECK(y[ma[2*a+1]].gq(home,ma[2*a]+1));			}					}		//prune values in x		if(x[ma[2*a+1]].assigned()&&y[ma[2*a+1]].min()>x[ma[2*a+1]].val()) {posx=-2; posy=-2; return home.ES_SUBSUMED(*this);}		 		if(!y[ma[2*a+1]].assigned()){			posy=ma[2*a+1];			 		} else posy=-2;		if(x[ma[2*a+1]].assigned()) {			posx=-2;			 			return ES_FIX;		}		else  		{ 			posx=ma[2*a+1];		 		} 		if(b==-1) 		{			if(mb[2*(y.size()-1)+1]<ma[2*a+1])				GECODE_ME_CHECK(x[ma[2*a+1]].lq(home,mb[2*(y.size()-1)]-1));			else 				GECODE_ME_CHECK(x[ma[2*a+1]].lq(home,mb[2*(y.size()-1)]));		}			if(b>-1)//x_a must be assigned its minimum value			if(mb[2*b+1]<ma[2*a+1])			{				 				GECODE_ME_CHECK(x[ma[2*a+1]].lq(home,mb[2*b]-1));			}			else if(mb[2*b+1]>ma[2*a+1])			{				//if(mb[2*b+1]==ma[2*a+1]) std::cout<<"equal now\n"; 				GECODE_ME_CHECK(x[ma[2*a+1]].lq(home,mb[2*b]));			}			else 			{				if(c==-1) 					GECODE_ME_CHECK(x[ma[2*a+1]].lq(home,mb[2*b]));				else 					GECODE_ME_CHECK(x[ma[2*a+1]].lq(home,mb[2*b]-1));			}		if(x[ma[2*a+1]].assigned()&&y[ma[2*a+1]].min()>x[ma[2*a+1]].val()) {posx=-2; posy=-2; return home.ES_SUBSUMED(*this);}   		return ES_FIX;	}  }; void reflex(Space& home, const IntVarArgs& x,const IntVarArgs& y) { 	// constraint post function 	ViewArray<Int::IntView> xv(home,x); 	ViewArray<Int::IntView> yv(home,y); 	if (RefLex<Int::IntView>::post(home,xv,yv)!= ES_OK)		home.fail(); }  void reflex(Space& home, const BoolVarArgs& x,const BoolVarArgs& y) { 	// constraint post function 	ViewArray<Int::BoolView> xv(home,x); 	ViewArray<Int::BoolView> yv(home,y); 	if (RefLex<Int::BoolView>::post(home,xv,yv)!= ES_OK)		home.fail(); } }